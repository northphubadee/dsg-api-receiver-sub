// Code generated by Prisma (prisma@1.25.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  currency: (where?: CurrencyWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  currency: (where: CurrencyWhereUniqueInput) => CurrencyPromise;
  currencies: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Currency>;
  currenciesConnection: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CurrencyConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCurrency: (data: CurrencyCreateInput) => CurrencyPromise;
  updateCurrency: (args: {
    data: CurrencyUpdateInput;
    where: CurrencyWhereUniqueInput;
  }) => CurrencyPromise;
  updateManyCurrencies: (args: {
    data: CurrencyUpdateManyMutationInput;
    where?: CurrencyWhereInput;
  }) => BatchPayloadPromise;
  upsertCurrency: (args: {
    where: CurrencyWhereUniqueInput;
    create: CurrencyCreateInput;
    update: CurrencyUpdateInput;
  }) => CurrencyPromise;
  deleteCurrency: (where: CurrencyWhereUniqueInput) => CurrencyPromise;
  deleteManyCurrencies: (where?: CurrencyWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  currency: (
    where?: CurrencySubscriptionWhereInput
  ) => CurrencySubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CurrencyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "iso4217_currency_numeric_code_ASC"
  | "iso4217_currency_numeric_code_DESC"
  | "iso4217_currency_alphabetic_code_ASC"
  | "iso4217_currency_alphabetic_code_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "payeeProxyId_ASC"
  | "payeeProxyId_DESC"
  | "payeeProxyType_ASC"
  | "payeeProxyType_DESC"
  | "payeeAccountNumber_ASC"
  | "payeeAccountNumber_DESC"
  | "payeeName_ASC"
  | "payeeName_DESC"
  | "payerProxyId_ASC"
  | "payerProxyId_DESC"
  | "payerProxyType_ASC"
  | "payerProxyType_DESC"
  | "payerAccountNumber_ASC"
  | "payerAccountNumber_DESC"
  | "payerName_ASC"
  | "payerName_DESC"
  | "sendingBankCode_ASC"
  | "sendingBankCode_DESC"
  | "receivingBankCode_ASC"
  | "receivingBankCode_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "transactionId_ASC"
  | "transactionId_DESC"
  | "transactionDateandTime_ASC"
  | "transactionDateandTime_DESC"
  | "billPaymentRef1_ASC"
  | "billPaymentRef1_DESC"
  | "billPaymentRef2_ASC"
  | "billPaymentRef2_DESC"
  | "currencyCode_ASC"
  | "currencyCode_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface PaymentCreateInput {
  payeeProxyId: String;
  payeeProxyType: String;
  payeeAccountNumber: String;
  payeeName: String;
  payerProxyId: String;
  payerProxyType: String;
  payerAccountNumber: String;
  payerName: String;
  sendingBankCode: String;
  receivingBankCode: String;
  amount: String;
  transactionId: String;
  transactionDateandTime: String;
  billPaymentRef1: String;
  billPaymentRef2: String;
  currencyCode: String;
  currency: String;
}

export type CurrencyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  iso4217_currency_numeric_code?: String;
}>;

export interface CurrencyUpdateInput {
  iso4217_currency_numeric_code?: String;
  iso4217_currency_alphabetic_code?: String;
}

export interface CurrencySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CurrencyWhereInput;
  AND?: CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput;
  OR?: CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput;
  NOT?: CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput;
}

export interface CurrencyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  iso4217_currency_numeric_code?: String;
  iso4217_currency_numeric_code_not?: String;
  iso4217_currency_numeric_code_in?: String[] | String;
  iso4217_currency_numeric_code_not_in?: String[] | String;
  iso4217_currency_numeric_code_lt?: String;
  iso4217_currency_numeric_code_lte?: String;
  iso4217_currency_numeric_code_gt?: String;
  iso4217_currency_numeric_code_gte?: String;
  iso4217_currency_numeric_code_contains?: String;
  iso4217_currency_numeric_code_not_contains?: String;
  iso4217_currency_numeric_code_starts_with?: String;
  iso4217_currency_numeric_code_not_starts_with?: String;
  iso4217_currency_numeric_code_ends_with?: String;
  iso4217_currency_numeric_code_not_ends_with?: String;
  iso4217_currency_alphabetic_code?: String;
  iso4217_currency_alphabetic_code_not?: String;
  iso4217_currency_alphabetic_code_in?: String[] | String;
  iso4217_currency_alphabetic_code_not_in?: String[] | String;
  iso4217_currency_alphabetic_code_lt?: String;
  iso4217_currency_alphabetic_code_lte?: String;
  iso4217_currency_alphabetic_code_gt?: String;
  iso4217_currency_alphabetic_code_gte?: String;
  iso4217_currency_alphabetic_code_contains?: String;
  iso4217_currency_alphabetic_code_not_contains?: String;
  iso4217_currency_alphabetic_code_starts_with?: String;
  iso4217_currency_alphabetic_code_not_starts_with?: String;
  iso4217_currency_alphabetic_code_ends_with?: String;
  iso4217_currency_alphabetic_code_not_ends_with?: String;
  AND?: CurrencyWhereInput[] | CurrencyWhereInput;
  OR?: CurrencyWhereInput[] | CurrencyWhereInput;
  NOT?: CurrencyWhereInput[] | CurrencyWhereInput;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  payeeProxyId?: String;
  payeeProxyId_not?: String;
  payeeProxyId_in?: String[] | String;
  payeeProxyId_not_in?: String[] | String;
  payeeProxyId_lt?: String;
  payeeProxyId_lte?: String;
  payeeProxyId_gt?: String;
  payeeProxyId_gte?: String;
  payeeProxyId_contains?: String;
  payeeProxyId_not_contains?: String;
  payeeProxyId_starts_with?: String;
  payeeProxyId_not_starts_with?: String;
  payeeProxyId_ends_with?: String;
  payeeProxyId_not_ends_with?: String;
  payeeProxyType?: String;
  payeeProxyType_not?: String;
  payeeProxyType_in?: String[] | String;
  payeeProxyType_not_in?: String[] | String;
  payeeProxyType_lt?: String;
  payeeProxyType_lte?: String;
  payeeProxyType_gt?: String;
  payeeProxyType_gte?: String;
  payeeProxyType_contains?: String;
  payeeProxyType_not_contains?: String;
  payeeProxyType_starts_with?: String;
  payeeProxyType_not_starts_with?: String;
  payeeProxyType_ends_with?: String;
  payeeProxyType_not_ends_with?: String;
  payeeAccountNumber?: String;
  payeeAccountNumber_not?: String;
  payeeAccountNumber_in?: String[] | String;
  payeeAccountNumber_not_in?: String[] | String;
  payeeAccountNumber_lt?: String;
  payeeAccountNumber_lte?: String;
  payeeAccountNumber_gt?: String;
  payeeAccountNumber_gte?: String;
  payeeAccountNumber_contains?: String;
  payeeAccountNumber_not_contains?: String;
  payeeAccountNumber_starts_with?: String;
  payeeAccountNumber_not_starts_with?: String;
  payeeAccountNumber_ends_with?: String;
  payeeAccountNumber_not_ends_with?: String;
  payeeName?: String;
  payeeName_not?: String;
  payeeName_in?: String[] | String;
  payeeName_not_in?: String[] | String;
  payeeName_lt?: String;
  payeeName_lte?: String;
  payeeName_gt?: String;
  payeeName_gte?: String;
  payeeName_contains?: String;
  payeeName_not_contains?: String;
  payeeName_starts_with?: String;
  payeeName_not_starts_with?: String;
  payeeName_ends_with?: String;
  payeeName_not_ends_with?: String;
  payerProxyId?: String;
  payerProxyId_not?: String;
  payerProxyId_in?: String[] | String;
  payerProxyId_not_in?: String[] | String;
  payerProxyId_lt?: String;
  payerProxyId_lte?: String;
  payerProxyId_gt?: String;
  payerProxyId_gte?: String;
  payerProxyId_contains?: String;
  payerProxyId_not_contains?: String;
  payerProxyId_starts_with?: String;
  payerProxyId_not_starts_with?: String;
  payerProxyId_ends_with?: String;
  payerProxyId_not_ends_with?: String;
  payerProxyType?: String;
  payerProxyType_not?: String;
  payerProxyType_in?: String[] | String;
  payerProxyType_not_in?: String[] | String;
  payerProxyType_lt?: String;
  payerProxyType_lte?: String;
  payerProxyType_gt?: String;
  payerProxyType_gte?: String;
  payerProxyType_contains?: String;
  payerProxyType_not_contains?: String;
  payerProxyType_starts_with?: String;
  payerProxyType_not_starts_with?: String;
  payerProxyType_ends_with?: String;
  payerProxyType_not_ends_with?: String;
  payerAccountNumber?: String;
  payerAccountNumber_not?: String;
  payerAccountNumber_in?: String[] | String;
  payerAccountNumber_not_in?: String[] | String;
  payerAccountNumber_lt?: String;
  payerAccountNumber_lte?: String;
  payerAccountNumber_gt?: String;
  payerAccountNumber_gte?: String;
  payerAccountNumber_contains?: String;
  payerAccountNumber_not_contains?: String;
  payerAccountNumber_starts_with?: String;
  payerAccountNumber_not_starts_with?: String;
  payerAccountNumber_ends_with?: String;
  payerAccountNumber_not_ends_with?: String;
  payerName?: String;
  payerName_not?: String;
  payerName_in?: String[] | String;
  payerName_not_in?: String[] | String;
  payerName_lt?: String;
  payerName_lte?: String;
  payerName_gt?: String;
  payerName_gte?: String;
  payerName_contains?: String;
  payerName_not_contains?: String;
  payerName_starts_with?: String;
  payerName_not_starts_with?: String;
  payerName_ends_with?: String;
  payerName_not_ends_with?: String;
  sendingBankCode?: String;
  sendingBankCode_not?: String;
  sendingBankCode_in?: String[] | String;
  sendingBankCode_not_in?: String[] | String;
  sendingBankCode_lt?: String;
  sendingBankCode_lte?: String;
  sendingBankCode_gt?: String;
  sendingBankCode_gte?: String;
  sendingBankCode_contains?: String;
  sendingBankCode_not_contains?: String;
  sendingBankCode_starts_with?: String;
  sendingBankCode_not_starts_with?: String;
  sendingBankCode_ends_with?: String;
  sendingBankCode_not_ends_with?: String;
  receivingBankCode?: String;
  receivingBankCode_not?: String;
  receivingBankCode_in?: String[] | String;
  receivingBankCode_not_in?: String[] | String;
  receivingBankCode_lt?: String;
  receivingBankCode_lte?: String;
  receivingBankCode_gt?: String;
  receivingBankCode_gte?: String;
  receivingBankCode_contains?: String;
  receivingBankCode_not_contains?: String;
  receivingBankCode_starts_with?: String;
  receivingBankCode_not_starts_with?: String;
  receivingBankCode_ends_with?: String;
  receivingBankCode_not_ends_with?: String;
  amount?: String;
  amount_not?: String;
  amount_in?: String[] | String;
  amount_not_in?: String[] | String;
  amount_lt?: String;
  amount_lte?: String;
  amount_gt?: String;
  amount_gte?: String;
  amount_contains?: String;
  amount_not_contains?: String;
  amount_starts_with?: String;
  amount_not_starts_with?: String;
  amount_ends_with?: String;
  amount_not_ends_with?: String;
  transactionId?: String;
  transactionId_not?: String;
  transactionId_in?: String[] | String;
  transactionId_not_in?: String[] | String;
  transactionId_lt?: String;
  transactionId_lte?: String;
  transactionId_gt?: String;
  transactionId_gte?: String;
  transactionId_contains?: String;
  transactionId_not_contains?: String;
  transactionId_starts_with?: String;
  transactionId_not_starts_with?: String;
  transactionId_ends_with?: String;
  transactionId_not_ends_with?: String;
  transactionDateandTime?: String;
  transactionDateandTime_not?: String;
  transactionDateandTime_in?: String[] | String;
  transactionDateandTime_not_in?: String[] | String;
  transactionDateandTime_lt?: String;
  transactionDateandTime_lte?: String;
  transactionDateandTime_gt?: String;
  transactionDateandTime_gte?: String;
  transactionDateandTime_contains?: String;
  transactionDateandTime_not_contains?: String;
  transactionDateandTime_starts_with?: String;
  transactionDateandTime_not_starts_with?: String;
  transactionDateandTime_ends_with?: String;
  transactionDateandTime_not_ends_with?: String;
  billPaymentRef1?: String;
  billPaymentRef1_not?: String;
  billPaymentRef1_in?: String[] | String;
  billPaymentRef1_not_in?: String[] | String;
  billPaymentRef1_lt?: String;
  billPaymentRef1_lte?: String;
  billPaymentRef1_gt?: String;
  billPaymentRef1_gte?: String;
  billPaymentRef1_contains?: String;
  billPaymentRef1_not_contains?: String;
  billPaymentRef1_starts_with?: String;
  billPaymentRef1_not_starts_with?: String;
  billPaymentRef1_ends_with?: String;
  billPaymentRef1_not_ends_with?: String;
  billPaymentRef2?: String;
  billPaymentRef2_not?: String;
  billPaymentRef2_in?: String[] | String;
  billPaymentRef2_not_in?: String[] | String;
  billPaymentRef2_lt?: String;
  billPaymentRef2_lte?: String;
  billPaymentRef2_gt?: String;
  billPaymentRef2_gte?: String;
  billPaymentRef2_contains?: String;
  billPaymentRef2_not_contains?: String;
  billPaymentRef2_starts_with?: String;
  billPaymentRef2_not_starts_with?: String;
  billPaymentRef2_ends_with?: String;
  billPaymentRef2_not_ends_with?: String;
  currencyCode?: String;
  currencyCode_not?: String;
  currencyCode_in?: String[] | String;
  currencyCode_not_in?: String[] | String;
  currencyCode_lt?: String;
  currencyCode_lte?: String;
  currencyCode_gt?: String;
  currencyCode_gte?: String;
  currencyCode_contains?: String;
  currencyCode_not_contains?: String;
  currencyCode_starts_with?: String;
  currencyCode_not_starts_with?: String;
  currencyCode_ends_with?: String;
  currencyCode_not_ends_with?: String;
  currency?: String;
  currency_not?: String;
  currency_in?: String[] | String;
  currency_not_in?: String[] | String;
  currency_lt?: String;
  currency_lte?: String;
  currency_gt?: String;
  currency_gte?: String;
  currency_contains?: String;
  currency_not_contains?: String;
  currency_starts_with?: String;
  currency_not_starts_with?: String;
  currency_ends_with?: String;
  currency_not_ends_with?: String;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface CurrencyCreateInput {
  iso4217_currency_numeric_code: String;
  iso4217_currency_alphabetic_code: String;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PaymentUpdateManyMutationInput {
  payeeProxyId?: String;
  payeeProxyType?: String;
  payeeAccountNumber?: String;
  payeeName?: String;
  payerProxyId?: String;
  payerProxyType?: String;
  payerAccountNumber?: String;
  payerName?: String;
  sendingBankCode?: String;
  receivingBankCode?: String;
  amount?: String;
  transactionId?: String;
  transactionDateandTime?: String;
  billPaymentRef1?: String;
  billPaymentRef2?: String;
  currencyCode?: String;
  currency?: String;
}

export interface CurrencyUpdateManyMutationInput {
  iso4217_currency_numeric_code?: String;
  iso4217_currency_alphabetic_code?: String;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface PaymentUpdateInput {
  payeeProxyId?: String;
  payeeProxyType?: String;
  payeeAccountNumber?: String;
  payeeName?: String;
  payerProxyId?: String;
  payerProxyType?: String;
  payerAccountNumber?: String;
  payerName?: String;
  sendingBankCode?: String;
  receivingBankCode?: String;
  amount?: String;
  transactionId?: String;
  transactionDateandTime?: String;
  billPaymentRef1?: String;
  billPaymentRef2?: String;
  currencyCode?: String;
  currency?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  payeeProxyId: String;
  payeeProxyType: String;
  payeeAccountNumber: String;
  payeeName: String;
  payerProxyId: String;
  payerProxyType: String;
  payerAccountNumber: String;
  payerName: String;
  sendingBankCode: String;
  receivingBankCode: String;
  amount: String;
  transactionId: String;
  transactionDateandTime: String;
  billPaymentRef1: String;
  billPaymentRef2: String;
  currencyCode: String;
  currency: String;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  payeeProxyId: () => Promise<String>;
  payeeProxyType: () => Promise<String>;
  payeeAccountNumber: () => Promise<String>;
  payeeName: () => Promise<String>;
  payerProxyId: () => Promise<String>;
  payerProxyType: () => Promise<String>;
  payerAccountNumber: () => Promise<String>;
  payerName: () => Promise<String>;
  sendingBankCode: () => Promise<String>;
  receivingBankCode: () => Promise<String>;
  amount: () => Promise<String>;
  transactionId: () => Promise<String>;
  transactionDateandTime: () => Promise<String>;
  billPaymentRef1: () => Promise<String>;
  billPaymentRef2: () => Promise<String>;
  currencyCode: () => Promise<String>;
  currency: () => Promise<String>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payeeProxyId: () => Promise<AsyncIterator<String>>;
  payeeProxyType: () => Promise<AsyncIterator<String>>;
  payeeAccountNumber: () => Promise<AsyncIterator<String>>;
  payeeName: () => Promise<AsyncIterator<String>>;
  payerProxyId: () => Promise<AsyncIterator<String>>;
  payerProxyType: () => Promise<AsyncIterator<String>>;
  payerAccountNumber: () => Promise<AsyncIterator<String>>;
  payerName: () => Promise<AsyncIterator<String>>;
  sendingBankCode: () => Promise<AsyncIterator<String>>;
  receivingBankCode: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<String>>;
  transactionId: () => Promise<AsyncIterator<String>>;
  transactionDateandTime: () => Promise<AsyncIterator<String>>;
  billPaymentRef1: () => Promise<AsyncIterator<String>>;
  billPaymentRef2: () => Promise<AsyncIterator<String>>;
  currencyCode: () => Promise<AsyncIterator<String>>;
  currency: () => Promise<AsyncIterator<String>>;
}

export interface CurrencyConnection {
  pageInfo: PageInfo;
  edges: CurrencyEdge[];
}

export interface CurrencyConnectionPromise
  extends Promise<CurrencyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CurrencyEdge>>() => T;
  aggregate: <T = AggregateCurrencyPromise>() => T;
}

export interface CurrencyConnectionSubscription
  extends Promise<AsyncIterator<CurrencyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CurrencyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCurrencySubscription>() => T;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface CurrencySubscriptionPayload {
  mutation: MutationType;
  node: Currency;
  updatedFields: String[];
  previousValues: CurrencyPreviousValues;
}

export interface CurrencySubscriptionPayloadPromise
  extends Promise<CurrencySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CurrencyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CurrencyPreviousValuesPromise>() => T;
}

export interface CurrencySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CurrencySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CurrencySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CurrencyPreviousValuesSubscription>() => T;
}

export interface Currency {
  id: ID_Output;
  iso4217_currency_numeric_code: String;
  iso4217_currency_alphabetic_code: String;
}

export interface CurrencyPromise extends Promise<Currency>, Fragmentable {
  id: () => Promise<ID_Output>;
  iso4217_currency_numeric_code: () => Promise<String>;
  iso4217_currency_alphabetic_code: () => Promise<String>;
}

export interface CurrencySubscription
  extends Promise<AsyncIterator<Currency>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  iso4217_currency_numeric_code: () => Promise<AsyncIterator<String>>;
  iso4217_currency_alphabetic_code: () => Promise<AsyncIterator<String>>;
}

export interface CurrencyEdge {
  node: Currency;
  cursor: String;
}

export interface CurrencyEdgePromise
  extends Promise<CurrencyEdge>,
    Fragmentable {
  node: <T = CurrencyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CurrencyEdgeSubscription
  extends Promise<AsyncIterator<CurrencyEdge>>,
    Fragmentable {
  node: <T = CurrencySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Payment {
  id: ID_Output;
  payeeProxyId: String;
  payeeProxyType: String;
  payeeAccountNumber: String;
  payeeName: String;
  payerProxyId: String;
  payerProxyType: String;
  payerAccountNumber: String;
  payerName: String;
  sendingBankCode: String;
  receivingBankCode: String;
  amount: String;
  transactionId: String;
  transactionDateandTime: String;
  billPaymentRef1: String;
  billPaymentRef2: String;
  currencyCode: String;
  currency: String;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  payeeProxyId: () => Promise<String>;
  payeeProxyType: () => Promise<String>;
  payeeAccountNumber: () => Promise<String>;
  payeeName: () => Promise<String>;
  payerProxyId: () => Promise<String>;
  payerProxyType: () => Promise<String>;
  payerAccountNumber: () => Promise<String>;
  payerName: () => Promise<String>;
  sendingBankCode: () => Promise<String>;
  receivingBankCode: () => Promise<String>;
  amount: () => Promise<String>;
  transactionId: () => Promise<String>;
  transactionDateandTime: () => Promise<String>;
  billPaymentRef1: () => Promise<String>;
  billPaymentRef2: () => Promise<String>;
  currencyCode: () => Promise<String>;
  currency: () => Promise<String>;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payeeProxyId: () => Promise<AsyncIterator<String>>;
  payeeProxyType: () => Promise<AsyncIterator<String>>;
  payeeAccountNumber: () => Promise<AsyncIterator<String>>;
  payeeName: () => Promise<AsyncIterator<String>>;
  payerProxyId: () => Promise<AsyncIterator<String>>;
  payerProxyType: () => Promise<AsyncIterator<String>>;
  payerAccountNumber: () => Promise<AsyncIterator<String>>;
  payerName: () => Promise<AsyncIterator<String>>;
  sendingBankCode: () => Promise<AsyncIterator<String>>;
  receivingBankCode: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<String>>;
  transactionId: () => Promise<AsyncIterator<String>>;
  transactionDateandTime: () => Promise<AsyncIterator<String>>;
  billPaymentRef1: () => Promise<AsyncIterator<String>>;
  billPaymentRef2: () => Promise<AsyncIterator<String>>;
  currencyCode: () => Promise<AsyncIterator<String>>;
  currency: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CurrencyPreviousValues {
  id: ID_Output;
  iso4217_currency_numeric_code: String;
  iso4217_currency_alphabetic_code: String;
}

export interface CurrencyPreviousValuesPromise
  extends Promise<CurrencyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  iso4217_currency_numeric_code: () => Promise<String>;
  iso4217_currency_alphabetic_code: () => Promise<String>;
}

export interface CurrencyPreviousValuesSubscription
  extends Promise<AsyncIterator<CurrencyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  iso4217_currency_numeric_code: () => Promise<AsyncIterator<String>>;
  iso4217_currency_alphabetic_code: () => Promise<AsyncIterator<String>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateCurrency {
  count: Int;
}

export interface AggregateCurrencyPromise
  extends Promise<AggregateCurrency>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCurrencySubscription
  extends Promise<AsyncIterator<AggregateCurrency>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Currency",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
